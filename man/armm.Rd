% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/armm.R
\name{armm}
\alias{armm}
\title{Autoregressive mixed model.}
\usage{
armm(
  formula,
  time_form,
  ar_form,
  y_scale,
  data = parent.frame(1L),
  obs_error = FALSE,
  distr = "normal",
  x_scale = TRUE,
  ar_bound = FALSE,
  hmc = TRUE,
  priors = NULL,
  change = TRUE,
  rstan_control = list()
)
}
\arguments{
\item{formula}{A required, two-sided, linear formula specifying both fixed
and random effects of the model.
The structure is similar to that in the \code{lme4} package, but more restrictive.
Random effects should be contained inside parentheses, and a bar (\code{|})
should separate the name of the fixed effect from the grouping variables.
All grouping variables must be factors without any missing levels.
Example: \code{y ~ x1 + (x2 | g1 + g2) + (x3 | g1 + g3)}.
\emph{Note:} If you do not explicitly specify a random effect for the intercept,
\code{armm} will not include one. This differs from \code{lmer}.
In the above example, the intercept will not have a random effect.}

\item{time_form}{A required, one-sided formula specifying the structure of
the time series (e.g., \code{~ time | species + site + rep}).
On the left side of the bar there should be the object indicating the actual
time point (e.g., day, hour), and on the right side there should be the
variables that, together, separate all time series.
No time series should ever span multiples of these variables.}

\item{ar_form}{A required, one-sided formula specifying the grouping to use for
the autoregressive parameter(s).
All groups present here should also be present in the grouping part of the
\code{time_form} argument; an error is thrown otherwise.
If you want to use a grouping variable here that a variable in \code{time_form}
is nested within (e.g., using genus here and species in \code{time_form}),
just insert the higher-level variable (genus in the example) in \code{time_form},
as it won't effect the results.
Providing \code{NULL} for this argument causes \code{armm} to use a model that does
not account for temporal autocorrelation. This can be useful for testing.}

\item{y_scale}{One-sided formula or character vector specifying the grouping
variable for scaling the response variable.
Scaling is done within each level of the grouping variable,
and this variable must be a factor.
Only one variable is allowed.
If \code{NULL}, no scaling is done for the y variable.
This argument is ignored if the error distribution is not normal.}

\item{data}{An optional list, data frame, or environment that contains
the dependent, independent, and grouping variables.
By default, it uses the environment the function was executed in.}

\item{obs_error}{Logical for whether to include observation error.
Defaults to \code{FALSE}.}

\item{distr}{String specifying the error distribution used.
Options are \code{"normal"} or \code{"lnorm_poisson"}. Defaults to \code{"normal"}.}

\item{x_scale}{Logical for whether to scale the independent variable(s).
Defaults to \code{TRUE}.}

\item{ar_bound}{An optional logical for whether to bound the autoregressive
parameter(s) <= 1. Defaults to \code{FALSE}.}

\item{hmc}{An optional logical for whether to use Hamiltonian Monte Carlo
sampling for the model fit.
This is \code{stan}'s default, and it gives samples from a posterior distribution
as output.
When \code{FALSE}, \code{armm} will obtain point estimates by maximizing the
joint posterior from the model and
returns standard errors based on the Hessian.
Note that this direct optimization has not been tested and may
perform poorly; use at your own risk.
Defaults to \code{TRUE}.}

\item{priors}{Named list specifying priors.
\code{NULL} results in the default priors being used.
An error is returned if this argument is not provided when not scaling
x or y variables.
See "Setting Priors" section for more information.
Defaults to \code{NULL}.}

\item{change}{An optional logical for whether predictors model the change
in the response variable between time points.
The alternative is for predictors to model the mean in the stationary
distribution of the response variable.
Defaults to \code{TRUE}.}

\item{rstan_control}{A list of arguments passed to \code{rstan::sampling}
or \code{rstan::optimizing}
(e.g., \code{iter}, \code{chains}, \code{cores}, \code{algorithm}).
See \code{\link[rstan]{sampling}} or \code{\link[rstan]{optimizing}}.}
}
\value{
A list containing, among other things, a \code{stanfit} object with the model fit.
}
\description{
Autoregressive mixed model.
}
\section{Setting priors}{

Priors are for the hyperparameters for the normal distributions of
fixed-effect coefficients and intercepts, random-effect standard deviations,
autoregressive parameters, and residual standard deviations.
Autoregressive parameters and standard deviation sampling distributions are
truncated above zero.
By default, most have priors of \eqn{\mu = 0} and \eqn{\sigma = 1}, except
for the autoregressive parameters that have priors of \eqn{\mu = 0} and
\eqn{\sigma = 0.5}.

To pass priors, you must provide a named list.
Each item in the list must be a 2-column matrix, with the first column
containing priors for \eqn{\mu} and the second containing those for
\eqn{\sigma}.
The possible names in the list are the following:
\describe{
\item{alpha}{ Fixed effects and intercepts }
\item{phi}{ Autoregressive parameters }
\item{sig_beta}{ Random effect group standard deviations }
\item{sig_res}{ Residual standard deviation }
}

If scaling is not done on either the x or y variables, then the user must
pass \emph{all} priors to replace these defaults.
}

\examples{
form_norm <- y_norm ~ x1 * x2 + x3 + (x1 * x2 | g1 + g2) + (x3 | g1) + (1 | g2)
form_poiss <- y_poiss ~ x1 * x2 + x3 + (x1 * x2 | g1 + g2) + (x3 | g1) + (1 | g2) +
              offset(log(effort))
time_form <- ~ t | tg + g1
ar_form <- ~ g1
y_scale <- ~ g1

set.seed(1)
b0 <- -4
x1_coef <- 1.5
x2_coefs <- runif(10, 1, 5)
data <- data.frame(g1 = factor(rep(1:5, each = 20)),
                   g2 = factor(rep(2:1, each = 50)),
                   y = numeric(100),
                   x1 = runif(100),
                   x2 = rnorm(100),
                   x3 = factor(rep(1:4, 25)),
                   t = rep(1:10, 10),
                   tg = factor(rep(1:10, each = 10)),
                   effort = exp(rnorm(100, 4)))
data$y <- b0 +
    data$x1 * x1_coef +
    data$x2 * sapply(as.integer(interaction(data$g1, data$g2)),
                     function(i) x2_coefs[i])
data$y_norm <- data$y + rnorm(100)
data$y_poiss <- rpois(100, exp(data$y) * data$effort) +
    round(rnorm(100, sd = 5)) |>
    (\(x) ifelse(x < 0, 0, x))()

mod_norm <- armm(form_norm, time_form, ar_form, y_scale, data,
                 rstan_control = list(chains = 1, iter = 100))
mod_poiss <- armm(form_poiss, time_form, ar_form, y_scale, data,
                  distr = "lnorm_poiss", obs_error = TRUE,
                  rstan_control = list(chains = 1, iter = 100))




}
